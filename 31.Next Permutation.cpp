/**************************************************************************/
题目：实现获取下一个排列函数，这个算法需要将数字重新排列成字典序中数字更大的排列。
如果不存在更大的排列，则重新将数字排列成最小的排列（即升序排列）。
修改必须是原地的，不开辟额外的内存空间。

思路：从后往前遍历数组，找到当前节点右侧第一个比当前节点大的数，交换他们，然后使当前右侧有序即可。 
假设数组nums长度为n（从0开始编号），数组中nums[i]到第nums[n-1]逆序（降序排列），且nums[i-1]<nums[i]，
则下一个全排列时只需要考虑nums[i-1]到nums[n-1]即可，在i-1 右侧找到第一个大于nums[i-1] 的数，交换他们顺序，
则后面升序排列就是最小的数，即下一个全排列

原理解释：https://www.toutiao.com/i6799039862184870412/?group_id=6799039862184870412?group_id=6799039862184870412

/**************************************************************************/


class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int len=nums.size();
        for(int i=len-1;i>=0;i--){
            for(int j=len-1;j>i;j--){
                if(nums[i]<nums[j]){
                    swap(nums[i],nums[j]);
                    sort(nums.begin()+i+1,nums.end());
                    return ;
                }
            }
        }
        reverse(nums.begin(),nums.end());
    }
};
