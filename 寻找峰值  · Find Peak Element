/*
你给出一个整数数组(size为n)，其具有以下特点：
相邻位置的数字是不同的
A[0] < A[1] 并且 A[n - 2] > A[n - 1]
假定P是峰值的位置则满足A[P] > A[P-1]且A[P] > A[P+1]，返回数组中任意一个峰值的位置。

即一个数组组成若干个山峰，要求至少长度为3，最左必须为升序，最右必须为降序。不允许存在两个相邻的数字相同（山峰为平顶的情况）
*/
思路：
不属于之前的二分法题目，不存在OOOOO OX XXXXXXXX，这样的序列。
但是，二分法的核心是要每做一次判断，删掉一半的数据，因此，我们可以分析一下，mid处在不同情况下如何删掉一半数据
1）mid处在升序，A[mid] < A[mid + 1]，右侧必然存在峰顶，删掉左侧；
2）mid处在降序，A[mid] < A[mid - 1]，左侧必然存在峰顶，删掉右侧；
3）mid处在山顶或者谷底，此时删左删右都可以，我们默认选择删右侧；


class Solution {
    /**
     * @param A: An integers array.
     * @return: return any of peek positions.
     */
    public int findPeak(vector<int> &A) {
        // write your code here
        int start = 1, end = A.length()-2; // 1.答案在之间，2.不会出界 
        while(start + 1 <  end) {
            int mid = (start + end) / 2;
            if(A[mid] < A[mid - 1]) {
            //情况1
                end = mid;
            } else if(A[mid] < A[mid + 1]) {
            //情况2
                start = mid;
            } else {
            //情况3
                end = mid;
            }
        }
        if(A[start] < A[end]) {
            return end;
        } else { 
            return start;
        }
    }
}
